// tmois lab1.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <vector> //библиотека для векторов
#include <iostream> //библиотека для потокового ввода/вывода
using namespace std; //чтобы не писать каждый раз std::

// ВВОД/ВЫВОД МНОЖЕСТВ

void vector_vivod(vector<double> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        cout << a[i] << " ";
        if ((i % 10 == 0) && (i != 0))  cout << endl; //для красоты
    }
    cout << endl;

    cout << "-----------------------------------------------------------------------" << endl;
}

// РАЗНОСТЬ МНОЖЕСТВ А\B

vector<double> raznost(vector<double> a, vector<double> b)
{
    vector<double> result;
    bool contain; //флаг вхождения

    for (int i = 0; i < a.size(); i++)
    {
        contain = false;
        for (int j = 0; j < b.size(); j++)
        {
            if (a[i] == b[j]) //условие, при котором a[i] не добавляется в результирующее множество
            {
                contain = true;
                break;
            }
        }

        if (contain == false) result.push_back(a[i]); //условие, при котором а[i] добавляется в результирующее множество
    }

    return result;
}

// ОБЪЕДИНЕНИЕ МНОЖЕСТВ

vector<double> obyedineniye(vector<double> a, vector<double> b) //A U B
{
    vector<double> result;
    bool contain; //флаг вхождения

    for (int i = 0; i < a.size(); i++) //заполнение результ. множества элементами множества "а"
    {
        result.push_back(a[i]);
    }

    for (int i = 0; i < b.size(); i++)
    {
        contain = false;
        for (int j = 0; j < a.size(); j++)
        {
            if (b[i] == result[j]) //условие, при котором b[i] не добавляется в результирующее множество
            {
                contain = true; 
                break;
            }
        }

        if (contain == false) result.push_back(b[i]); //условие, при котором b[i] добавляется в результирующее множество
    }

    return result;
}

// ПРОВЕРКА НА ОТСУТСТВИЕ ПОВТОРЯЮЩИХСЯ ЭЛЕМЕНТОВ ПРИ ВВОДЕ

bool vector_is_uniq(vector<double> a)
{
    bool uniq = true; //флаг уникальности
    for (int i = 0; i < a.size(); i++)
    {
        int elem_povt = 0; //счетчик повторений элемента a[i]
        for (int j = 0; j < a.size(); j++)
        {
            if (a[i] == a[j]) elem_povt++; //условие, при котором счетчик возрастает на 1
        }

        if (elem_povt > 1) //условие, при котором множество имеет повторяющиеся элементы. При его истинности закрывает цикл, uniq = false
        {
            uniq = false;
            break;
        }
    }

    return uniq;
}

int main()
{
    system("chcp 1251"); //для поддержки русского языка

    int size_X, size_Y, N; //размер X, размер Y, больший элемент универсального множества соответственно
    int x, y; //переменные для ввода элементов соотв. множеств

    vector<double> mnV; //для промежуточных значений
    vector<double> mnU; //универсальное множество

    cout << "Далее задайте больший член множества U. Оно будет создано по принципу {1, 2, 3, ..., N}" << endl << "N = ";

    cin >> N;

    for (int i = 1; i <= N; i++) //создание универсального множества
    {
        mnU.push_back(i);
    }

    cout << "Введите мощность первого множества (X): ";
    cin >> size_X;

    while (size_X > N)
    {
        cout << "Мощность множества не может быть множества универсума. Повторите ввод: ";
        cin >> size_X;
    }

    cout << "Введите мощность первого множества (Y): ";
    cin >> size_Y;

    while (size_Y > N)
    {
        cout << "Мощность множества не может быть множества универсума. Повторите ввод: ";
        cin >> size_Y;
    }

    if (size_X > N || size_Y > N)
    {
        cout << "Множества X/Y больше, чем универсальное множество. Проверьте ввод и попробуйте снова.";
        return 0;

    }

    vector<double> mnX(size_X); //множество X
    vector<double> mnY(size_Y); //множество Y

    cout << "Введите элементы множества X: ";
    for (int i = 0; i < size_X; i++)
    {
        cin >> x;
        if (x <= N && x >= 1)
        {
            mnX[i] = x;
        }
        else
        {
            cout << "Вы задали неверное значение. Повторите ввод." << endl;
            i = i - 1;
        }
    }

    while (vector_is_uniq(mnX) == false) //проверка на повт. элементы во множестве
    {
        cout << "Множество X имеет повторяющиеся элементы. Проверьте вводные данные и попробуйте снова." << endl;
        cout << "Введите элементы множества X: ";
        for (int i = 0; i < size_X; i++)
        {
            cin >> x;
            if (x <= N && x >= 1)
            {
                mnX[i] = x;
            }
            else
            {
                cout << "Вы задали неверное значение. Повторите ввод." << endl;
                i = i - 1;
            }
        }
    }

    cout << "Введите элементы множества Y: ";
    for (int i = 0; i < size_Y; i++)
    {
        cin >> y;
        if (y <= N && y >= 1)
        {
            mnY[i] = y;
        }
        else
        {
            cout << "Вы задали неверное значение. Повторите ввод." << endl;
            i = i - 1;
        }
    }

    while (vector_is_uniq(mnY) == false) //проверка на повт. элементы во множестве
    {
        cout << "Множество Y имеет повторяющиеся элементы. Проверьте вводные данные и попробуйте снова." << endl;
        cout << "Введите элементы множества Y: ";
        for (int i = 0; i < size_Y; i++)
        {
            cin >> y;
            if (y <= N && y >= 1)
            {
                mnY[i] = y;
            }
            else
            {
                cout << "Вы задали неверное значение. Повторите ввод." << endl;
                i = i - 1;
            }
        }
    }

    cout << "-----------------------------------------------------------------------" << endl;
    //ПЕРЕСЕЧЕНИЕ
    cout << "Пересечение: " << endl;
    for (int i = 0; i < size_X; i++)
    {
        for (int j = 0; j < size_Y; j++)
        {
            if (mnX[i] == mnY[j]) //при наличии одинакового элемента в обоих множествах записывает его в результирующее множества
            {
                mnV.push_back(mnX[i]);
            }
        }
    }
    
    vector_vivod(mnV);

    //ОБЪЕДИНЕНИЕ
    cout << "Объединение: " << endl;
    
    mnV = obyedineniye(mnX, mnY); //вызов функции, запись результата в множество mnV

    vector_vivod(mnV); //вывод через заранее написанную функцию

    //РАЗНОСТЬ X\Y

    cout << "Разность X\\Y: " << endl;

    mnV = raznost(mnX, mnY);

    vector_vivod(mnV);

    //РАЗНОСТЬ Y\X

    cout << "Разность Y\\X: " << endl;

    mnV = raznost(mnY, mnX);

    vector_vivod(mnV);

    //СИММЕТРИЧНАЯ РАЗНОСТЬ

    cout << "Симметричная разность (X\\Y)U(Y\\X): " << endl;
    
    mnV = obyedineniye(raznost(mnX, mnY), raznost(mnY, mnX));

    vector_vivod(mnV);
    

    //ДОПОЛНЕНИЕ X

    cout << "Дополнение U\\X: " << endl;

    mnV = raznost(mnU, mnX);

    vector_vivod(mnV);

    //ДОПОЛНЕНИЕ Y

    cout << "Дополнение U\\Y: " << endl;

    mnV = raznost(mnU, mnY);

    vector_vivod(mnV);

    return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
